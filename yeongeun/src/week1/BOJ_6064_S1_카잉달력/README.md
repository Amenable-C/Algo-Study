# Week1 브루트 포스

## BOJ_6064_S1_카잉달력
- 문제

```
그들은 이 세상의 시초에 해당하는 첫 번째 해를 <1:1>로 표현하고, 두 번째 해를 <2:2>로 표현하였다.
<x:y>의 다음 해를 표현한 것을 <x':y'>이라고 하자. 만일 x < M 이면 x' = x + 1이고, 그렇지 않으면 x' = 1이다.
같은 방식으로 만일 y < N이면 y' = y + 1이고, 그렇지 않으면 y' = 1이다.
<M:N>은 그들 달력의 마지막 해로서, 이 해에 세상의 종말이 도래한다는 예언이 전해 온다. 

예를 들어, M = 10 이고 N = 12라고 하자. 첫 번째 해는 <1:1>로 표현되고, 11번째 해는 <1:11>로 표현된다.
<3:1>은 13번째 해를 나타내고, <10:12>는 마지막인 60번째 해를 나타낸다. 

네 개의 정수 M, N, x와 y가 주어질 때, <M:N>이 카잉 달력의 마지막 해라고 하면
<x:y>는 몇 번째 해를 나타내는지 구하는 프로그램을 작성하라. 
```
- 아이디어:   
	1. 1476 날짜계산처럼 그냥 세면될것같음. (시간초과)
		- 모든 경우의 수를 다 세서 그런것이 아닐까...
	2. +1씩 하는것보다 시간초과가 안날 방법으로 떠올린 방법. M의 주기, N의 주기를 계산하도록한다.
		
		cur값으로 x,y를 구할 수 있으면 멈추도록.

		```
		예시1. <10,12>일 때 주기
		- M : 1 10  20  30  40  50 60
		- N : 1   12  24  36  48   60
		
		+ x : 1 1  3 1 5 1 7 1 9 1 3
		+ y : 1 11 1 9 1 7 1 5 1 3 1
		```

  
- 생각해 볼 부분:  
	+ x, y가 유효하지 않은 경우를 고려해야한다.
		- (1,1)부터 +1씩하면서 다시 (1,1)로 돌아오면 (x,y)가 검색되지 않는다는 것으로 판단.
	+ 아이디어 2의 멈추는 조건을 생각해야한다.
		- 만약 M:10, N:12, x:2, y:12로 들어왔다면, 위의 조건에서 3번째 1,11에서 두개 모두 +1한 값과 같으니
		
			```(x - cx) == (y - cy)```조건으로 생각하였다.
	+ 아이디어 2의 주기를 높일때 ```M:39999 N:2 x:39998 y:2``` 와 같이 차이가 많이나는 숫자가 들어올 수 있으므로
	
		addNum할 숫자를 정할 때 현재 위치에서 주기에 더 가까운 수로 주기를 돌말큼 더해주었다.
		
		```
		예시2. M : 2 , N : 15, x : 2, y : 14
			+-------+-------+-------+-------+-------+-------+-------+-------+
			| 	curx	|	cury	|     x - cx	|     y - cy
			|	1	|	1	|	 1	|	13
		(+2)
			|	1	|	3	|	 1	|	11
		(+2)
			|	1	|	5	|	 1	|	9
		(+2)
			|	1	|	7	|	 1	|	7
		(+2)
			|	1	|	9	|	 1	|	5
		(+2)
			|	1	|	11	|	 1	|	3
		(+2)
			|	1	|	13	|	 1	|	1
		(break)
		
		```
		
	



- 결과

```
+ 메모리 : 18500 KB
+ 시간 : 448 ms
```
