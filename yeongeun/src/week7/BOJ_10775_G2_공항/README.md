# Week7 BOJ_10775_G2_공항

## 접근방법
풀이방법을 4개 생각해냈다.
1. 내가 도착할 수 있는 장소에 있는 비행기 수 count하기

	-> 시간 : O(P\*G) = O(10^10), 공간: 4\*10^5
2. 먼저 도착한 비행기들의 g(i)번호 확인하고 count하기

	-> 시간 : O(P^2) = O(10^10), 공간: 4\*10^5

3. 현재 자리에 바로 도킹. 이미 도킹되어 있으면 한칸씩 앞으로

	-> 시간 : O(P\*G) = O(10^10), 공간: 10^5

4. 현재 자리에 바로 도킹, 현재 자리에 다음번에 또 들어오면 앉을 수 있는 자리를 저장. (union find)

	-> 시간 : α(P) 라는데 높이설정이 다 된건 아니고 편향 트리가 될 수도 있으니까 그것보단 좀 더 크지 않을까 싶다, 공간: 10^5

여기서 정답인 코드는 4번이다.
나머지는 모두 시간초과

<br>

## 실행 흐름
1. G,P입력
2. P개만큼 반복하면서 g(i)입력

	1. g(i)가 도킹할 자리가 없으면 break 결과출력.
	2. 있으면 도킹한 자리에다가 다음에 이 숫자가 들어오면 앉아야 할 자리번호 적음.



<br>

## 결과

|메모리|시간|
|:---:|:---:|
|25540 KB|252 ms|

풀이시간 : 1시간

처음 1,2를 계획하고서 이거 100억번이니까 100초라 무조건 안되겠네 하고 넣어봤는데 진짜 시간초과가 났다..!! (사실 다른 아이디어가 딱히 안떠올라서 일단 돌려봤다)

그러고나서 그리디라는 힌트를 보고 3번을 작성하니 71%에서 시간초과가 나길래 이거 최적화만 하면 되겠다 하고 최적화알고리즘 적고 보니까 유니온 파인드였다..ㅋㅋㅋㅋ
배웠으면서 왜 문제보고 바로 캐치를 못한 걸까ㅜㅜ 안푸니까 또 까먹은 것 같다,, 문제풀기 게을리하지 말아야지

이번에 처음 계획 적고 검증하는데까지 20분 걸렸는데 앞으로는 문제풀기전에 고민시간을 더 늘려야겠다.. 

그리고 이번에 알게된 사실! 유니온 파인드의 시간복잡도는 α(N)이다~ 애커만(Ackermann) 역함수
```
1≤N<3인 경우 	α(N)=1
3≤N<7인 경우 	α(N)=2
7≤N<63인 경우 	α(N)=3
63≤N<2^2^2^65536인 경우 	α(N)=4
```
*저게 도대체 얼마나 큰 숫자인거야,,,*