# Week2

## BOJ_10972_S3_다음순열

### 문제

```
1부터 N까지의 수로 이루어진 순열이 있다. 이때, 사전순으로 다음에 오는 순열을 구하는 프로그램을 작성하시오.

사전 순으로 가장 앞서는 순열은 오름차순으로 이루어진 순열이고, 가장 마지막에 오는 순열은 내림차순으로 이루어진 순열이다.

N = 3인 경우에 사전순으로 순열을 나열하면 다음과 같다.

1, 2, 3
1, 3, 2
2, 1, 3
2, 3, 1
3, 1, 2
3, 2, 1
```
<br>

### 아이디어
1. 그냥 모든 순열을 구하면 N이 10_000까지 올 수 있으니까 경우의 수 다 구한다면 최악의 경우 10_000!
2. 1의자리수부터 (왼 < 오) 인 경우를 찾아서 해당 index부터해서 순열을 구한다.
	- 이때 내림차순으로 정렬되어있다면 다음순열을 찾지않고 -1을 출력한다.
	- 예시 : 입력[2,3,4,1] -> 2(index 1) 자리부터 남아있는 숫자들로 순열을 구한다.
		```
		[2, 3, 1, 4]
		[2, 3, 4, 1]
		[2, 4, 1, 3]
		[2, 4, 3, 1]
		```
	- 최악의 경우 : 입력[1,4,3,2] 숫자 1이 첫째자리이면서 둘째자리부터는 내림차순으로 되어있는경우. 모든 순열의 경우의 수를 구한다. (멈추는 법을 모르겠음.)

2. 2에서 구한 순열을 List에 넣는다. 입력받은 array의 index값의 +1 index에 array가 결과!

<br>

### 어려웠던 점
- List에서 index값 구하기가 어려웠다. ```List<int[]>```라서 더 그랬던 것 같다.
- List에서 원래 Object의 index를 구할때 list.indexOf()하면 되는데 배열이라 주소값이 비교되어서(arr1 == arr2) 안된 것 같다.
- 찾아보니 배열이 같은가? 를 구할땐 Arrays.equals(arr1,arr2) 메소드를 사용한다더라.
	- arr1.equals(arr2)는 주소값 비교라서 값이 같아도 false나옴.
- list 전체를 돌아서 index를 찾는 부분에서 시간이 많이 소요되는 것 같다. 아마 다른 방법을 찾아봐야 할 것 같다.
	- 순열 구하는 부분을 조금 바꿨는데도 시간차이가 별로 안났기 때문에.

<br>

### 결과

|메모리|시간|
|:---:|:---:|
|21352 KB|184 ms|
|20308 KB|188 ms|
