
## 성능 요약
메모리: 145812 KB  
시간 : 772 ms  
소요시간 : 2시간  


## 접근 방법
첫번째 예제를 예시로 들어봄

### 피자조각의 경우의 수 구하기
피자A의 각 칸을 1,2,3,4,5번이라고 index를 붙여보자  
피자A에서 나올 수 있는 피자조각의 경우의 수는 아래와 같다  
1. 1, 12, 123, 1234, 12345 -> 5개
2. 2, 23, 234, 2345 -> 4개
3. 3, 34, 345, 3451 -> 4개
4. 4, 45, 451, 4512 -> 4개
5. 5, 51, 512, 5123 -> 4개
=> 총 21개  


- Asum[]에 1~해당 index까지의 누적합을 구해놓으면 1번의 각 피자조각의 크기는 쉽게 구할 수 있다  
- 2번의 피자조각의 크기또한 Asum을 통해 구할 수 있다 -> 2 : Asum[2] - Asum[2 - 1], 3 : Asum[3] - Asum[2 - 1], ...  
- 3번의 피자조각 또한 Asum을 통해 구할 수 있지만 3451의 경우 따로 예외처리를 해줘야함 -> Asum[5]-Asum[2]+Asum[1]  
- 나머지 4,5번의 피자조각 또한 3번과 같다  

### 손님이 원하는 크기의 피자를 판매하는 모든 방법의 가지 수 계산
- 피자조각의 경우의 수를 구할 때 나온 피자조각 크기를 map에 저장(key : 피자조각 크기, value : 해당 크기의 피자조각 개수) 

   
1. 피자A의 map을 반목문으로 꺼내면서 손님이 원하는 크기보다 크면 패스  
2. 손님이 원하는 크기와 같다면 피자B를 볼 필요없이 바로 result에 추가  
3. 남은 크기를 피자B에서 채울 수 있다면 피자A의 개수 x 피자B의 개수를 추가(경우의 수이므로 x)
4. 피자B 단독으로 손님이 원하는 크기를 만들 수 있을 때 result에 추가 


## 회고
피자 문제 진짜 어려웠다..  
코드를 짜는게 어려운게 아니라 어떻게 접근해야하는지 떠올리는게 너무 힘들었다ㅜㅜ  
생각만 1시간 넘게 하다가 필기를 해보니 규칙을 찾아서 해당 식을 바탕으로 코드를 작성하니 바로 패스 했다  
이래서 논리적인 흐름이 중요한 것 같다!  
현재 코드에서 중복된 부분이 많아서 따로 함수를 빼면 좋을 것 같은데 시간이 늦어서 나중에 해봐야겠다  

