# 1937 G3 욕심쟁이 판다

### 📂 풀이
1. 해당 위치를 기준으로 최대한 많이 움직일 수 있는 값을 저장할 수 있으므로 DP를 이용하여 풀었다.
2. 이동할 위치의 DP값이 있는 경우 (이동할 위치의 DP값 + 1), 없는 경우 DP 값을 탐색한 후 (이동할 위치의 DP값 + 1)로 현재 위치의 DP값을 설정해주었다.
3. 숲의 크기와 4방향만 움직일 수 있다는 점을 고려하면, 500x500x4 = 1_000_000의 시간 복잡도를 가진다.

### 📌 기타
1. 처음에는 visited를 사용하여 이미 지나간 자리를 다시 지나가는 일이 없도록 설계하였다.
2. 하지만, 다음 지역은 무조건 현재 지역보다 대나무가 많아야 하므로 visited를 따로 고려하지 않아도 왔던 위치를 되돌아 갈 일이 없다.
3. 또한, 위에서 말한대로 설계를 하면 반복문 안에서 'visited = new boolean[N][N]'을 해줘야 하는데, 배열을 생성할 때에는 배열에 접근, 추가, 삭제할때보다 말도 안되게 많은 비용이 발생한다고 한다.
4. 그래서 시간초과가 발생한다는 문제도 있다.